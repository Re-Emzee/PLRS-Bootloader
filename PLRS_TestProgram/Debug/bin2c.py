#!/usr/bin/env python3
import sys

def bin2c(bin_filename, c_filename, var_name):
    """
    Reads a binary file (bin_filename) and creates a C file (c_filename)
    with a const uint8_t array named var_name.
    """
    # Read the entire binary file into memory
    with open(bin_filename, 'rb') as f:
        data = f.read()

    # Open the output C file for writing
    with open(c_filename, 'w') as c:
        # Write a header comment
        c.write("/*\n")
        c.write(f" * This file was automatically generated from {bin_filename}\n")
        c.write(" * DO NOT EDIT THIS FILE MANUALLY!\n")
        c.write(" */\n\n")
        c.write("#include <stdint.h>\n\n")
        
        # Declare the constant array
        c.write(f"const uint8_t {var_name}[] = {{\n")
        
        # Write the binary data as hexadecimal bytes
        line_width = 12  # number of bytes per line
        for i, byte_val in enumerate(data):
            if i % line_width == 0:
                c.write("    ")
            c.write(f"0x{byte_val:02X}, ")
            if (i + 1) % line_width == 0:
                c.write("\n")
        c.write("\n};\n\n")
        
        # Declare a variable for the length of the array
        c.write(f"const unsigned int {var_name}_len = {len(data)};\n")

def main():
    # Check if the correct number of arguments are provided
    if len(sys.argv) != 4:
        print("Usage: python bin2c.py <input.bin> <output.c> <array_name>")
        sys.exit(1)

    bin_file = sys.argv[1]
    c_file = sys.argv[2]
    var_name = sys.argv[3]
    
    # Generate the C file from the binary file
    bin2c(bin_file, c_file, var_name)
    print(f"Generated {c_file} from {bin_file} with array '{var_name}'")

if __name__ == "__main__":
    main()
